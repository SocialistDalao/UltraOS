# Shell 设计

Shell是我们设计的除了初始进程之外的第一个用户程序。和通常情况不一样的是，我们将其作为第二个初始程序，随着初始程序一同运行，初始程序负责回收僵尸进程，而Shell则负责进行自动化测试以及UltraOS内部命令调试。但是，实际上，对于比赛来说，shell没有什么大的用处，但是我们还是把他放进来了，因为这更加符合操作系统通用的设计。我们尽量少的为大赛做妥协。

### Shell 命令

shell可以直接执行位于当前目录下的所有程序，直接以命令的形式运行即可。

> root@UltraOS: / >>usertests

同时，我们还支持一些全局命令

> run_testsuites //运行初赛测试用例
> 
> cd //切换当前目录
> 
> autorun //自动运行初赛测试用例并关机
> 
> ls //打印当前目录下的文件

### Input Machine

ASCII：键盘的上下左右由三字节的ascii组成
十进制

左键 27 91 68

右键 27 91 67

上键 27 91 65

下键 27 91 66

这其实是ANSI escape中的控制码CSI，这意味着我们现在面临的实际上不仅有一个字节的ascii的请情况。考虑到今后处理字符串的复杂性以及shell本身处理的可拓展性，我们决定采用状态机的方式来处理相关的字符串输入。

CSI就是27，用键盘打ctrl+[就是这个字符，因此在linux中可以看到其显示出来是^[，当我们遇见了^[[D这样的字符，其实代表键盘按下了右键。

字符串处理机。我们将其设置在shell之外，以保证其拓展性，今后能够复用至其他的模块，只要是有关字符串输入的。该处理机能够保证用户输入的时候满足对应的限制，不会出现不能识别以及破坏输入框的情况，同时还能正确的处理用户的输入，将其转为对应的字符串以供程序进一步处理。

我们将其介绍放置在shell模块，实际上是因为这是关于输出的控制模块。

当前该状态机支持左右键以及delte的正确处理，对于上下键则进行无效果处理。但是对于一些不知道怎么办的CSI控制序列，比如esc等，我们直接进入panic停止操作系统的运行。

状态机的设计有五个状态，其中四个为对应处理1，2，3，4个字符，最后一个状态是panic，用来表示不可预见的状态。处理1个字符的状态是通用的一个ascii码的字符，而2，3，4则是表示多字符的CSI控制序列.

现在,我们发现了一些问题:在vscode使用ssh远程连接到服务器,启动qemu执行UltraOS的时候,在printCSI序列的时候,经常会出现CSI字符无法正确使用的现象,使得CSI序列变成可显示字符打印在终端上.虽然在K210上以及不通过ssh直接运行在qume上,都不会出现这个问题,但是我们发现在不常见的极端情况,也会出现类似的现象.这使得我们非常疑惑,完全没有思考方向和解决方案.



### Arg Machine

实际上，我们在shell设计了两个处理机，这一个处理机是为了将input_machine得到的字符串处理成相应的参数格式.目前,在只支持非递归重定向,不支持管道命令的情况之下,arg machine 的功能还非常有限.

### cd(chdir)

shell需要支持cd命令,同时文件系统也需要支持多目录,与此同时系统调用open也需要支持相对路径.

我们的实现方案是,shell会存储当前所在的路径以进行打印.但是同时在内核的pcb中,会将文件当前存在的目录位置以inode id进行标识,这样就可以方便的使用相对路径进行切换(相对路径以及绝对路径的解析放在内核),这样的好处之一就是对open等命令的支持.

在实现的时候,我们发现一个非常隐蔽的问题,那就是字符串"cd\0"不等于"cd".这是因为rust中的str和c中的char*(string)不同,&str是vec\<u8\>,维护两个字长信息单元：一个指针指向str的第一个字节，另一个指针描述str的字节数。在将字符串传递给内核的时候,我们需要在字符串尾部防止一个\0,因为我们要人为找到字符串的终点,而本来应该维护的信息单元则停留在了用户栈中,所以为了传递而加的\0会隐式的存在于args字符串的末尾(因为\0是不被终端显示的),因此在字符串匹配的时候要格外小心.


### Auto Run


### More to do

实际上，在翻阅xv6源码使用linux的shell的时候发现，大概有下面两点：内核console、特殊控制操作shell（管道，重定向以及基本命令）。

- 为每个stdio都创造一个缓存区，并且加入配套的支持。（取消计划，os比赛不需要构建用户库）
- shell：shell必须要支持更多的基本操作，包括cat，mv等，重定向，管道等等指令。这一部分要在arg machine中实现，用来解析用户的命令，并且做相应的实现。（实现，但不优雅）
- 内核监控：在debug层面，构建内部os的监控系统，通过shell能够调用专用的系统调用或者是程序来打印出内部操作系统的信息，文件系统占有率，当前进程状态，内存空间状态等等。(实现)
- c语言应用程序支持:提供两种API,一种为c语言,一种为rust语言,以支持相应的程序编写,当前我们支持rust,接下来支持c.（实现）
- 更多syscall支持:POSIX7文档有三千多页,完全铺开展示,还不如直接把rcore看作文档,将其最重要的系统调用接口进行开发支持.(神经病，对着大赛硬怼就好了，还翻POSIX文档，我当时是傻逼)
