### 信号机制

本部分属于kernel中进程控制模块的信号机制。

信号也称为类软中断的一种模拟机制，但是这并不是软中断。根据所查资料显示，系统调用等来自cpu内部程序已经设计好的确定的中断才是软件中断，但是那些来自cpu外围的需要中途打断程序的是硬中断。

信号的机制主要分为三种：信号的产生，信号的注册与注销、信号的执行。

#### 信号的产生

##### 什么是信号

信号分为实时信号（可信信号）和非实时信号（不可信信号）。一共有三十二种信号，标号为0-31，32-63是这三十二种的重复，只不过为实时信号。

Linux支持的信号列表如下。很多信号是与机器的体系结构相关的

信号值 默认处理动作 发出信号的原因

SIGHUP 1 A 终端挂起或者控制进程终止

SIGINT 2 A 键盘中断（如break键被按下）

SIGQUIT 3 C 键盘的退出键被按下

SIGILL 4 C 非法指令

SIGABRT 6 C 由abort(3)发出的退出指令

SIGFPE 8 C 浮点异常

SIGKILL 9 AEF Kill信号

SIGSEGV 11 C 无效的内存引用

SIGPIPE 13 A 管道破裂: 写一个没有读端口的管道

SIGALRM 14 A 由alarm(2)发出的信号

SIGTERM 15 A 终止信号

SIGUSR1 30,10,16 A 用户自定义信号1

SIGUSR2 31,12,17 A 用户自定义信号2

SIGCHLD 20,17,18 B 子进程结束信号

SIGCONT 19,18,25 进程继续（曾被停止的进程）

SIGSTOP 17,19,23 DEF 终止进程

SIGTSTP 18,20,24 D 控制终端（tty）上按下停止键

SIGTTIN 21,21,26 D 后台进程企图从控制终端读

SIGTTOU 22,22,27 D 后台进程企图从控制终端写

 

处理动作一项中的字母含义如下

A 缺省的动作是终止进程

B 缺省的动作是忽略此信号，将该信号丢弃，不做处理

C 缺省的动作是终止进程并进行内核映像转储（dump core），内核映像转储是指将进程数据在内存的映像和进程在内核结构中的部分内容以一定格式转储到文件系统，并且进程退出执行，这样做的好处是为程序员提供了方便，使得他们可以得到进程当时执行时的数据值，允许他们确定转储的原因，并且可以调试他们的程序。

D 缺省的动作是停止进程，进入停止状况以后还能重新进行下去，一般是在调试的过程中（例如ptrace系统调用）

E 信号不能被捕获

F 信号不能被忽略


##### 如何存储信号

Linux采用的是bit位进行信号的标志，但是我们采用的是队列。如果信号到达了，就放入队列之中，队列中标识了信号(bitflags(usize))的数值。我们与linux保持一致，优先处理信号量最大的操作。因此，我们使用优先队列来做相应的操作。同时，这也意味着我们信号存储是实时的，可靠的。

> signal_pending: BinaryHeap<Signals>

#### 信号的注册与注销

这是为了更改对应信号的处理逻辑，为用途提供定制化需求。

信号的注册又叫信号的安装（Installation），通常调用的syscall为rt_sigaction。

##### 如何注册

int sigaction(int signum,const struct sigaction *act,struct sigaction *oldact));

该方法将信号进行注册，一共有32个信号。为了能够迅速定位到对应的信号处理函数，我们可以设置一个32项的数组，对应32个信号的处理函数先设置为默认值。但是这会增大PCB的大小，因此我们采取HashMap，注册的时候就加入，寻找的时候直接以信号量为键值寻找即可。这样得结构非常适合每个信号量只对应一个信号处理函数的对应机制，而且我们也可以在新的信号处理函数注册的同时，将老的注册函数返回给用户。

> SigHandler = BTreeMap::new()

##### 如何注销

将信号对应的处理函数取出原来的堆即可。


#### 信号的产生、发送

信号可以通过自身遇见的事件产生，也可以进程自己创造信号发送给指定的进程。进程在收到信号的时候会根据处理函数进行相应的处理。


##### 产生信号

进程自身会因为终止、出现pagefault，闹钟终止等事件产生自身的信号。当然，进程自身终止还会给父进程发送子进程已经死亡的信号，这也属于信号产生的范围。他们产生之后会放进进程控制块PCB内存储，而不会立刻被处理（软中断）。这里不会立即被处理，是从绝对时间来看的，对于进程自身来看，是会被立即处理的，因为在运行其他进程的时候没有必要处理和很难处理非自身进程的信号。

##### 发送信号

进程可以通过sys_kill向自身或者孩子等合法的进程发送信号。发送的信号可以是原生的，也可以是自定义的。

#### 信号的处理

##### 处理的时机

那信号什么时候处理呢？首先，应该在trap return的时候进行扫描，并且在这个时候进行信号的处理。

但是还有一些其他的信号，比如说SIG_KILL，需要杀死进程，但是子进程现在可能没有办法进入trap_return，这个时候KILL就无法生效，对应的进程还在执行自身的内核操作，特别是阻塞操作，会触发调度。

因此，我们需要在调度的时候判定是否出现了上述情况，以终止该进程的运行。


##### 处理的方法

信号处理需要在用户程序中运行相应的程序，我们需要给予一个独立的堆栈（signal stack）和一个独立的上下文。这样的话，在确定需要运行用户信号处理程序的时候，就切换到这个栈。同时，我们还要备份原来程序正常执行的上下文，在信号函数处理完毕的时候再恢复回来。

这里面还有一个问题，那就是如何让程序在执行信号处理程序结束之后能够返回内核。通过反汇编，我们发现这个信号处理程序就是一个函数，因此结束的时候只会调用ret。那么我们就应该设计一个跳板，让程序能够执行完后ret到这个地方，跳板（signal trampoline）数据很简单，只有一个sigreturn的系统调用操作。要想ret到跳板，只要把进入信号处理程序的上下文中的ra改成跳板所在位置就可以了。

##### 信号处理过程的注意

信号处理的时候可能还会发生内核trap，或者是一些异常或者是中断。UltraOS在trap的时候也会和往常一样保存对应的上下文，trap return的时候也会恢复。出现了异常和中断就按照对应的处理程序进行，但是唯独有一点需要注意。我们可能还会遇见一个新的信号处理事件，这个时候我们只会按照默认的方式处理！因为目前UltraOS不支持信号的嵌套，因为这会用到多个信号的堆栈，还会设计到屏蔽信号的设计。