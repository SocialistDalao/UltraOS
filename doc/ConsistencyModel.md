## Memory Consistency Model

RISC-V采用的是弱一致性模型，这意味着CPU能够有更高的性能去运行程序，而将数据一致性的处理交付给了操作系统。因此我们需要在优化的时候，好好利用对应的机制，来提升我们的性能。严格说来，其实这不止是性能的问题，在多核支持中，不规范的使用将会造成更加严重的功能上的问题。

但是，关于RISC-V的内存一致性模型，UltraOS还了解的不够深刻和全面，因此以下内容很可能有一定的错误，望指正。

### 概述

UltraOS需要解决这几个重要的数据部件：ICache、DCache、TLB以及Memory。

对于单核内，ICache和DCache内部的数据不是同步的，这意味着修改了代码段的数据，需要显式的通知ICache进行更新。DCache和Memory显然也不是同步的，也需要显式的通知。TLB和Memory是不同步的，和DCache也是不同步的。但是操作系统知道什么时候不同步，因此需要显式的使用一些指令来进行手动同步。

同时额外需要注意的是，我们认为，多核的DCache之间的数据一致性应该会保证，也就是说各个DCache之间的数据是同步的。但是内存和他们不同步，TLB也看不见，各自的ICache也看不见。

接下来，我们将简要的介绍（文档编写的时间不太充足了）相关指令的作用，指令应该如何使用，以及我们现在的设计需要怎样适配和实现。


### 相关指令

实际上，在k210上只有这三条指令：sfence.vm, fence, fence.i。根据我们的理解，作用如下：

- sfence.vm：刷新TLB。这样被动的将TLB与内存同步。
- fence：刷新DCache，主动的将其中的数据同步到内存。这样全局都可以看到相关的数据。
- fence.i：刷新ICache和取指前端，被动的将ICache和DCache以及内存同步。简单的说，之前这个核写的ICache现在都看得到了。但是这只能保证这个核心是这样的，要是别的核心改了指令的代码，那么就得跨核做相应的同步了，好像RISC-V上有提到EEI与这种情况相关，不知道这是啥。

sfence.vma指令是新版的指令，代替了sfence.vm。似乎可以针对某个地址来进行TLB刷新了，更高效了。其他的区别暂时不是很了解。


### 使用相关指令的时机

根据以上的特性，我们需要大致总结出相应的指令的使用时机。

- TLB Shootdown：当全局页表被修改的时候，需要给所有核心同步并且使用，需要刷新所有的TLB，这个时候我们需要对当前进程使用fence，将数据同步进内存，然后ecall进入sbi使用IPI告知所有核心使用sfence刷新TLB。
- 修改进程页表项： 修改实际上有添加、删除、修改权限三种操作。
  - 添加：应该要使用fence将添加的页表项同步进内存。
  - 删除：不进使用fence同步，还要刷新TLB。
  - 修改：同删除。
- 更换页表：同步TLB即可，sfence。
- 修改代码：同步ICache，fence.i。多核情况，需要fence（所有核心的ICache都能够看到对代码修改，进程切换的时候就可以察觉到相应的变化），再fence.i。


### UltraOS使用相关指令的时机

- 我们的设计不会出现TLB Shootdown，不需要对应操作。
- 更换页表的时候只会在进程调度的时候，这个时候我们会刷新TLB。
- exec会修改代码，需要fence然后是fence.i
- lazy和CoW以及mmap和mprotect会修改页表，因此需要在操作后fence+刷新TLB（这类操作是最常见的）。
